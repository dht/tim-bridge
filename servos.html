<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>6DOF Arm Calibration View (Servos 1–4)</title>
    <style>
      :root {
        --bg: #0b0f14;
        --panel: #121a24;
        --panel2: #0f1620;
        --text: #e7eef8;
        --muted: #a9b6c8;
        --grid: #253246;
        --accent: #58a6ff;
        --range: #2dd4bf;
        --zero: #f59e0b;
        --link: #a78bfa;
        --joint: #e879f9;
        --danger: #fb7185;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
          Arial, "Noto Sans", "Liberation Sans", sans-serif;
        background: var(--bg);
        color: var(--text);
      }
      header {
        padding: 16px 18px;
        border-bottom: 1px solid #1d2a3d;
        background: linear-gradient(180deg, #0c121b, #0b0f14);
      }
      header h1 {
        margin: 0 0 6px 0;
        font-size: 16px;
        font-weight: 650;
      }
      header .sub {
        color: var(--muted);
        font-size: 13px;
        line-height: 1.35;
      }
      main {
        display: grid;
        grid-template-columns: 1.1fr 0.9fr;
        gap: 14px;
        padding: 14px;
        max-width: 1200px;
        margin: 0 auto;
      }
      .card {
        background: var(--panel);
        border: 1px solid #1d2a3d;
        border-radius: 12px;
        overflow: hidden;
      }
      .card .hd {
        padding: 12px 12px 10px;
        border-bottom: 1px solid #1d2a3d;
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 10px;
      }
      .card .hd .title {
        font-weight: 650;
      }
      .card .hd .hint {
        color: var(--muted);
        font-size: 12px;
      }
      .card .bd {
        padding: 12px;
      }
      .views {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
      }
      .viewWrap {
        background: var(--panel2);
        border: 1px solid #1d2a3d;
        border-radius: 10px;
        padding: 10px;
      }
      .viewRow {
        display: grid;
        grid-template-columns: 1fr 0.45fr;
        gap: 12px;
        align-items: start;
      }
      canvas {
        width: 100%;
        height: auto;
        display: block;
        background: #0a0e13;
        border: 1px solid #1d2a3d;
        border-radius: 10px;
      }

      .controls {
        display: grid;
        gap: 12px;
      }
      .servoCard {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
        align-items: center;
        padding: 10px;
        border: 1px solid #1d2a3d;
        border-radius: 10px;
        background: var(--panel2);
      }
      .servoMeta {
        display: grid;
        gap: 8px;
      }
      .servoMeta .name {
        font-weight: 650;
      }
      .servoMeta .desc {
        color: var(--muted);
        font-size: 12px;
        line-height: 1.3;
      }
      .row {
        display: grid;
        grid-template-columns: 110px 1fr;
        gap: 8px;
        align-items: center;
      }
      .row label {
        color: var(--muted);
        font-size: 12px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 6px;
      }
      .row .angleValue {
        color: var(--text);
        font-weight: 650;
        font-size: 12px;
      }
      input[type="range"] {
        width: 100%;
      }
      .legend {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        color: var(--muted);
        font-size: 12px;
        margin-top: 8px;
      }
      .chip {
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .dot {
        width: 10px;
        height: 10px;
        border-radius: 999px;
        background: #fff;
      }
      .dot.range {
        background: var(--range);
      }
      .dot.zero {
        background: var(--zero);
      }
      .dot.link {
        background: var(--link);
      }
      .dot.joint {
        background: var(--joint);
      }
      .dot.base {
        background: var(--accent);
      }
      .dot.limit {
        background: var(--danger);
      }
      footer {
        padding: 10px 14px 18px;
        max-width: 1200px;
        margin: 0 auto;
        color: var(--muted);
        font-size: 12px;
        line-height: 1.4;
      }
      @media (max-width: 980px) {
        main {
          grid-template-columns: 1fr;
        }
        .viewRow {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>

  <body>
    <header>
      <h1>Robotic Arm Calibration (Servos 1–4)</h1>
      <div class="sub">
        Purpose: visually calibrate each servo’s <b>mechanical 0°</b> and see
        the resulting arm pose in <b>side</b> and <b>top</b> projections.
      </div>
    </header>

    <main>
      <section class="card">
        <div class="hd">
          <div class="title">Arm Views</div>
          <div class="hint">
            Side view prioritized; top view smaller (projection only).
          </div>
        </div>
        <div class="bd views">
          <div class="viewRow">
            <div class="viewWrap">
              <div
                style="
                  display: flex;
                  justify-content: space-between;
                  align-items: baseline;
                  margin: 0 0 8px 2px;
                "
              >
                <div style="font-weight: 650">Side View (Servo #2–#4)</div>
                <div style="color: var(--muted); font-size: 12px">
                  Units: cm (scaled)
                </div>
              </div>
              <canvas id="sideCanvas" width="900" height="520"></canvas>
              <div class="legend">
                <span class="chip"><span class="dot base"></span>Base</span>
                <span class="chip"><span class="dot joint"></span>Joint</span>
                <span class="chip"><span class="dot link"></span>Link</span>
                <span class="chip"
                  ><span class="dot range"></span>Dial range</span
                >
                <span class="chip"
                  ><span class="dot zero"></span>Zero indicator</span
                >
                <span class="chip"
                  ><span class="dot limit"></span>Out of range cue</span
                >
              </div>
            </div>

            <div class="viewWrap">
              <div
                style="
                  display: flex;
                  justify-content: space-between;
                  align-items: baseline;
                  margin: 0 0 8px 2px;
                "
              >
                <div style="font-weight: 650">Top View (Servo #1 yaw)</div>
                <div style="color: var(--muted); font-size: 12px">
                  Smaller (less important)
                </div>
              </div>
              <canvas id="topCanvas" width="520" height="520"></canvas>
              <div
                style="
                  color: var(--muted);
                  font-size: 12px;
                  margin-top: 8px;
                  line-height: 1.35;
                "
              >
                Servo #1 mapping: <b>0° = left</b> from base,
                <b>180° = right</b> from base.
              </div>
            </div>
          </div>
        </div>
      </section>

      <section class="card">
        <div class="hd">
          <div class="title">Servo Calibration</div>
          <div class="hint">
            Adjust the raw servo angles; views update live with your changes.
          </div>
        </div>
        <div class="bd controls" id="controls"></div>
      </section>
    </main>

    <footer>
      Geometry used (cm): Shoulder axis is <b>6</b> above base. Shoulder→Elbow:
      <b>10.5</b>, Elbow→Wrist: <b>14.5</b>, Wrist→End (servo #5 position):
      <b>7</b>. Servos #5 (grip position) and grip spin/open are ignored in
      controls; servo #5 is drawn as the final 7 cm segment.
    </footer>

    <script>
      (() => {
        // -----------------------------
        // Model / configuration
        // -----------------------------
        const geom = {
          baseToShoulderZ: 6.0,
          L2: 10.5,
          L3: 14.5,
          L4: 7.0,
        };

        const servoSpecs = [
          {
            id: 1,
            name: "Servo #1 (Base yaw)",
            desc: "Top view rotation. 0° = left from base; 180° = right from base.",
          },
          {
            id: 2,
            name: "Servo #2 (Shoulder pitch)",
            desc: "Side view. 0° = 45° back from straight up (top/back).",
          },
          {
            id: 3,
            name: "Servo #3 (Elbow pitch)",
            desc: "Side view. 0° is 180° opposite from servo #2 direction.",
          },
          {
            id: 4,
            name: "Servo #4 (Wrist pitch)",
            desc: "Side view. Relative wrist pitch: -90°..+90° around servo #3.",
          },
        ];

        const ANGLE_MIN = 0;
        const ANGLE_MAX = 180;

        const state = {
          servos: {
            1: { angleDeg: 90 },
            2: { angleDeg: 0 },
            3: { angleDeg: 90 },
            4: { angleDeg: 90 },
          },
        };

        // -----------------------------
        // DOM: build calibration blocks
        // -----------------------------
        const controls = document.getElementById("controls");

        function clamp(v, a, b) {
          return Math.max(a, Math.min(b, v));
        }
        function degToRad(d) {
          return (d * Math.PI) / 180;
        }

        function buildServoCard(spec) {
          const wrap = document.createElement("div");
          wrap.className = "servoCard";

          const meta = document.createElement("div");
          meta.className = "servoMeta";

          const name = document.createElement("div");
          name.className = "name";
          name.textContent = spec.name;

          const desc = document.createElement("div");
          desc.className = "desc";
          desc.textContent = spec.desc;

          const rowAngle = document.createElement("div");
          rowAngle.className = "row";
          const la = document.createElement("label");
          const lt = document.createElement("span");
          lt.textContent = "Angle";
          la.appendChild(lt);
          const lv = document.createElement("span");
          lv.className = "angleValue";
          lv.textContent = `${state.servos[spec.id].angleDeg}°`;
          la.appendChild(lv);
          const ra = document.createElement("input");
          ra.type = "range";
          ra.min = ANGLE_MIN;
          ra.max = ANGLE_MAX;
          ra.step = 1;
          ra.value = state.servos[spec.id].angleDeg;

          rowAngle.appendChild(la);
          rowAngle.appendChild(ra);

          meta.appendChild(name);
          meta.appendChild(desc);
          meta.appendChild(rowAngle);

          wrap.appendChild(meta);

          function syncFromAngle(v) {
            v = clamp(Math.round(+v || 0), ANGLE_MIN, ANGLE_MAX);
            state.servos[spec.id].angleDeg = v;
            ra.value = v;
            lv.textContent = `${v}°`;
          }

          ra.addEventListener("input", () => syncFromAngle(ra.value));

          return { wrap, spec };
        }

        servoSpecs.forEach((spec) => {
          const { wrap } = buildServoCard(spec);
          controls.appendChild(wrap);
        });

        // -----------------------------
        // Drawing helpers
        // -----------------------------
        function resizeCanvasToCSSPixels(canvas) {
          const rect = canvas.getBoundingClientRect();
          const dpr = Math.max(1, window.devicePixelRatio || 1);
          const w = Math.max(2, Math.floor(rect.width * dpr));
          const h = Math.max(2, Math.floor(rect.height * dpr));
          if (canvas.width !== w || canvas.height !== h) {
            canvas.width = w;
            canvas.height = h;
          }
          return { w, h, dpr };
        }

        function clear(ctx, w, h) {
          ctx.clearRect(0, 0, w, h);
          ctx.fillStyle = "#0a0e13";
          ctx.fillRect(0, 0, w, h);
        }

        function drawGrid(ctx, w, h, stepPx) {
          ctx.save();
          ctx.lineWidth = 1;
          ctx.strokeStyle =
            getComputedStyle(document.documentElement)
              .getPropertyValue("--grid")
              .trim() || "#253246";
          ctx.globalAlpha = 0.8;
          ctx.beginPath();
          for (let x = 0; x <= w; x += stepPx) {
            ctx.moveTo(x, 0);
            ctx.lineTo(x, h);
          }
          for (let y = 0; y <= h; y += stepPx) {
            ctx.moveTo(0, y);
            ctx.lineTo(w, y);
          }
          ctx.stroke();
          ctx.restore();
        }

        // -----------------------------
        // Kinematics & views
        // -----------------------------
        function computeSidePose() {
          const s2 = state.servos[2].angleDeg;
          const s3 = state.servos[3].angleDeg;
          const s4 = state.servos[4].angleDeg;

          const shoulder = { x: 0, z: geom.baseToShoulderZ };

          const abs2 = degToRad(135 - s2);
          const elbow = {
            x: shoulder.x + Math.cos(abs2) * geom.L2,
            z: shoulder.z + Math.sin(abs2) * geom.L2,
          };

          // Elbow mapping (flipped so +90 is not mirrored)
          const abs3 = abs2 + degToRad(s3 - 180);

          const wrist = {
            x: elbow.x + Math.cos(abs3) * geom.L3,
            z: elbow.z + Math.sin(abs3) * geom.L3,
          };

          const abs4 = abs3 + degToRad(-(s4 - 90));
          const end = {
            x: wrist.x + Math.cos(abs4) * geom.L4,
            z: wrist.z + Math.sin(abs4) * geom.L4,
          };

          return { shoulder, elbow, wrist, end };
        }

        function drawSideView() {
          const canvas = document.getElementById("sideCanvas");
          const { w, h } = resizeCanvasToCSSPixels(canvas);
          const ctx = canvas.getContext("2d");
          clear(ctx, w, h);

          const pose = computeSidePose();
          const pts = [
            { x: 0, z: 0 },
            pose.shoulder,
            pose.elbow,
            pose.wrist,
            pose.end,
          ];

          let minX = Infinity,
            maxX = -Infinity,
            minZ = Infinity,
            maxZ = -Infinity;
          for (const p of pts) {
            minX = Math.min(minX, p.x);
            maxX = Math.max(maxX, p.x);
            minZ = Math.min(minZ, p.z);
            maxZ = Math.max(maxZ, p.z);
          }

          const pad = 6;
          minX -= pad;
          maxX += pad;
          minZ -= pad;
          maxZ += pad;

          const rangeX = Math.max(1e-6, maxX - minX);
          const rangeZ = Math.max(1e-6, maxZ - minZ);

          const margin = 34;
          const sx = (w - margin * 2) / rangeX;
          const sz = (h - margin * 2) / rangeZ;
          const s = Math.min(sx, sz);

          const toPx = (p) => ({
            x: margin + (p.x - minX) * s,
            y: h - (margin + (p.z - minZ) * s),
          });

          const stepPx = 5 * s;
          if (stepPx >= 14) drawGrid(ctx, w, h, stepPx);

          const css = getComputedStyle(document.documentElement);
          const colBase = css.getPropertyValue("--accent").trim();
          const colLink = css.getPropertyValue("--link").trim();
          const colJoint = css.getPropertyValue("--joint").trim();
          const colText = css.getPropertyValue("--muted").trim();

          const basePx = toPx({ x: 0, z: 0 });
          ctx.save();
          ctx.strokeStyle = "#2a3950";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(0, basePx.y);
          ctx.lineTo(w, basePx.y);
          ctx.stroke();
          ctx.restore();

          const p0 = toPx({ x: 0, z: 0 });
          const p1 = toPx(pose.shoulder);
          const p2 = toPx(pose.elbow);
          const p3 = toPx(pose.wrist);
          const p4 = toPx(pose.end);

          ctx.save();
          ctx.lineWidth = 6;
          ctx.lineCap = "round";
          ctx.strokeStyle = colLink;

          ctx.beginPath();
          ctx.moveTo(p0.x, p0.y);
          ctx.lineTo(p1.x, p1.y);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(p2.x, p2.y);
          ctx.lineTo(p3.x, p3.y);
          ctx.stroke();
          ctx.globalAlpha = 0.75;
          ctx.beginPath();
          ctx.moveTo(p3.x, p3.y);
          ctx.lineTo(p4.x, p4.y);
          ctx.stroke();
          ctx.restore();

          function joint(pt, r, fill) {
            ctx.save();
            ctx.fillStyle = fill;
            ctx.beginPath();
            ctx.arc(pt.x, pt.y, r, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
          joint(p0, 8, colBase);
          joint(p1, 7, colJoint);
          joint(p2, 7, colJoint);
          joint(p3, 7, colJoint);
          joint(p4, 5, "#cbd5e1");

          ctx.save();
          ctx.fillStyle = colText;
          ctx.font = "12px ui-sans-serif, system-ui, sans-serif";
          ctx.fillText("Base", p0.x + 10, p0.y - 10);
          ctx.fillText("Shoulder (+6cm)", p1.x + 10, p1.y - 10);
          ctx.fillText("Elbow (+10.5cm)", p2.x + 10, p2.y - 10);
          ctx.fillText("Wrist (+14.5cm)", p3.x + 10, p3.y - 10);
          ctx.fillText("End (+7cm)", p4.x + 10, p4.y - 10);
          ctx.restore();
        }

        function drawTopView() {
          const canvas = document.getElementById("topCanvas");
          const { w, h } = resizeCanvasToCSSPixels(canvas);
          const ctx = canvas.getContext("2d");
          clear(ctx, w, h);

          const pose = computeSidePose();
          const yaw = state.servos[1].angleDeg;

          const dir = degToRad(180 - yaw);

          const base = { x: 0, y: 0 };
          const shoulderXY = { x: 0, y: 0 };

          function rot(r) {
            return { x: Math.cos(dir) * r, y: Math.sin(dir) * r };
          }

          const elbowXY = rot(pose.elbow.x);
          const wristXY = rot(pose.wrist.x);
          const endXY = rot(pose.end.x);

          const pts = [base, shoulderXY, elbowXY, wristXY, endXY];

          let minX = Infinity,
            maxX = -Infinity,
            minY = Infinity,
            maxY = -Infinity;
          for (const p of pts) {
            minX = Math.min(minX, p.x);
            maxX = Math.max(maxX, p.x);
            minY = Math.min(minY, p.y);
            maxY = Math.max(maxY, p.y);
          }
          const pad = 6;
          minX -= pad;
          maxX += pad;
          minY -= pad;
          maxY += pad;

          const rangeX = Math.max(1e-6, maxX - minX);
          const rangeY = Math.max(1e-6, maxY - minY);

          const margin = 28;
          const s = Math.min(
            (w - 2 * margin) / rangeX,
            (h - 2 * margin) / rangeY
          );

          const toPx = (p) => ({
            x: margin + (p.x - minX) * s,
            y: margin + (p.y - minY) * s,
          });

          const stepPx = 5 * s;
          if (stepPx >= 16) drawGrid(ctx, w, h, stepPx);

          const css = getComputedStyle(document.documentElement);
          const colBase = css.getPropertyValue("--accent").trim();
          const colLink = css.getPropertyValue("--link").trim();
          const colJoint = css.getPropertyValue("--joint").trim();
          const colText = css.getPropertyValue("--muted").trim();

          const p0 = toPx(base);
          const p2 = toPx(elbowXY);
          const p3 = toPx(wristXY);
          const p4 = toPx(endXY);

          ctx.save();
          ctx.lineWidth = 5;
          ctx.lineCap = "round";
          ctx.strokeStyle = colLink;

          ctx.beginPath();
          ctx.moveTo(p0.x, p0.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(p2.x, p2.y);
          ctx.lineTo(p3.x, p3.y);
          ctx.stroke();
          ctx.globalAlpha = 0.75;
          ctx.beginPath();
          ctx.moveTo(p3.x, p3.y);
          ctx.lineTo(p4.x, p4.y);
          ctx.stroke();
          ctx.restore();

          function joint(pt, r, fill) {
            ctx.save();
            ctx.fillStyle = fill;
            ctx.beginPath();
            ctx.arc(pt.x, pt.y, r, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
          joint(p0, 8, colBase);
          joint(p2, 6.5, colJoint);
          joint(p3, 6.5, colJoint);
          joint(p4, 5, "#cbd5e1");

          ctx.save();
          ctx.strokeStyle = colBase;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(p0.x, p0.y);
          ctx.lineTo(
            p0.x + Math.cos(dir) * Math.min(w, h) * 0.35,
            p0.y + Math.sin(dir) * Math.min(w, h) * 0.35
          );
          ctx.stroke();
          ctx.fillStyle = colText;
          ctx.font = "12px ui-sans-serif, system-ui, sans-serif";
          ctx.fillText(`Yaw effective: ${yaw}°`, 10, 18);
          ctx.fillText("0°=Left, 180°=Right", 10, 34);
          ctx.restore();
        }

        // -----------------------------
        // Render loop
        // -----------------------------
        function render() {
          drawSideView();
          drawTopView();
          requestAnimationFrame(render);
        }

        window.addEventListener("resize", () => {});
        render();
      })();
    </script>
  </body>
</html>
